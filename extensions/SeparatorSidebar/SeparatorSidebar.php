<?php
if ( !defined( 'MEDIAWIKI' ) ) {
	die( 'This file is a MediaWiki extension, it is not a valid entry point' );
}
 
$wgExtensionCredits['other'][] = array(
    'name' => 'SeparatorSidebar',
	'version' => '0.1.0',
    'author' => 'Thierry Crozat',
    'description' => 'Add possibility to display separators and use wiki formating in Sidebar',
	'url'     => '',
);
 
$wgHooks['SkinBuildSidebar'][] = 'fnSeparatorSidebar';
 
function fnSeparatorSidebar($skin, &$bar) {
	global $wgParser, $wgUser, $wgTitle;

 	/* Get content of SideBar page */
 	$lines = explode( "\n", wfMsgForContent( 'sidebar' ) );
 
	if ($lines && count($lines) > 0) {
		/* init the parser */
		$opt = null;
		if (!is_object($wgParser)) {
		    $wgParser = new Parser();
		    $opt = $wgParser->mOptions;
		}
		if (!is_object($opt)) {
		    $opt = ParserOptions::newFromUser($wgUser);
		}
 
 		/* Iterate on the lines */
		for ($i = 0; $i < sizeof($lines); $i++) {
			$line = $lines[$i];
 			
			if (strpos($line, '**') === 0 && $i > 0) {
				/* Line start with two '*' => This is the start of a new box */
				/* Parse the text for the box (after which $i is set to the last line of the box */
				$bar[$title] = fnBuildSeparatorSidebarBox($lines, $i, $opt);
			}
			else {
				/* Line start with only on '*' => this is the title for the following box */
				$title = trim($line, '* ');
			}	
		}
	}

	return true;
}

/* This function parse the given lines starting at the given line $i
 * It returns at the end of the block (i.e. when the next line that begins
 * with only one '*' is encountered or when all the lines have been read.
 * When the function returns, $i is set to the last line of the block that
 * has been parsed. */
function fnBuildSeparatorSideBarBox($lines, &$i, $opt) {
	global $wgParser, $wgTitle;

	$content = "<ul>";
	for (;$i < sizeof($lines); $i++) {
		$line = $lines[$i];
 
 		/* Check we are still in the same block and not on the title of the next one */
		if (strpos($line, '**') === 0) {
			/* Check if we have a corect syntax 'link|text' */
			if (strpos($line, '|') !== false) {
				/* Separate the text from the link and resolve both */
				$line = array_map('trim', explode( '|' , trim($line, '** '), 2 ) );
				$link = wfMsgForContent( $line[0] );
				if ($link == '-')
					continue;
					
				$text = wfMsgExt($line[1], 'parsemag');
				if (wfEmptyMsg($line[1], $text))
					$text = $line[1];
				if (wfEmptyMsg($line[0], $link))
					$link = $line[0];

				if ( preg_match( '/^(?:' . wfUrlProtocols() . ')/', $link ) ) {
					$href = $link;
				} else {
					$title = Title::newFromText( $link );
					if ( $title ) {
						$title = $title->fixSpecialName();
						$href = $title->getLocalURL();
					} else {
						$href = 'INVALID-TITLE';
					}
				}
				/* protect special characters in link */
				/* we do not need to (and should not) do it for the text since it will be done by the parser */
				$href = htmlspecialchars($href);
				/* Parse the resolved text (e.g. for the formatting) */
				$text = $wgParser->parse($text, $wgTitle, $opt, true, true)->getText();
				$text = substr(trim($text),3,-5); // removes <p> and \n</p> that is generated by the parser
				/* add to box content */
				$content .= "<li><a href=\"$href\">$text</a></li>";
			}
			else {
				/* We don't have a link */
				/* If the text is a single '-', replace it by a horizontal separator line */
				/* Otherwis display the text as is */
				$text = trim($line, '** ');
				if ($text == "-") {
					$content .= "</ul><hr><ul>";
				} else {
					/* Parse the text (e.g. for the formatting) */
					$text = $wgParser->parse($text, $wgTitle, $opt, true, true)->getText();
					$text = substr(trim($text),3,-5); // removes <p> and \n</p> that is generated by the parser
					/* add to box content */
					$content .= "<li>$text</li>";
				}
			}
		} else {
			break;
		}
	}

	$content .= "</ul>";
	$i--;
	return $content;
}